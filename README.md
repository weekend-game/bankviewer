## BankViewer

The program opens text files of bank statements, represented by key-value pairs, and displays them in a table. I use [Eclipse](https://www.eclipse.org/) for development. The program implements SDI and is written in [Java](https://docs.oracle.com/javase/tutorial/index.html) and [Swing](https://docs.oracle.com/javase/tutorial/uiswing/index.html). I use Java 11, but for such a simple program, the Java version does not matter.

The program opens text files of bank statements, represented by key-value pairs, and displays them in a table. I use Eclipse for development. The program implements SDI and is written in Java and Swing. I use Java 11, but for such a simple program, the Java version does not matter.

Swing provides the JTable class for displaying information in a table. But there is another way: we make an HTML file with `<table>...</table>` tags and pass it to an object of the JEditorPane class. I use the second option. So, the main thing in the program is to convert the key-value text file into an HTML file. Everything else is the implementation of SDI and ensuring the usability of the program.

The project has a standalone program **TestGenerator**. It is located in the package game.weekend.bankviewer.util. In the program text, you can specify the file name, the number of lines of the bank statement, and it will generate a test file. Statement1.txt was generated by TestGenerator.

You can launch the program from Eclipse by double-clicking on the BankViewer.jar file, or if it does not launch, by double-clicking on the BankViewer.bat file. If the application does not launch, download and install Java 11 or newer.

The main class of the application is the **BankViewer** class. Everything necessary for work is created in its constructor. First of all, this is the application window - an object of the JFrame class. To implement SDI, I use the BorderLayout() layout manager. In the central part, I place a JEditorPane. It will be used to display a bank statement in the form of a table. In the upper part, I place the toolbar, and in the lower part, the status bar.

It is worth paying attention to the **Proper** class. This is a class that is a wrapper for the java.util.Properties class. The read() method reads a file with previously recorded key-value pairs of an object of the java.util.Properties class. The save() method does the opposite: it writes everything in the object to a file. The class is needed so that the application can save some data between work sessions. It saves the location and size of the main window, paths to several recently opened files, the flag of the toolbar display, the status bar, the last entered search string, and some other data. For convenience, two methods are implemented: setProperty(name, value) and getProperty(name, def), where value can be a string or an integer. It is clear that the first method saves a certain value with the name, and the second reads the value, and if it was not written, the value of def will be returned. A pair of saveBounds() and setBounds() methods is used to record and restore the location and size of the application window.

A menu is attached to the main application window. The context menu is attached to the JEditorPane, and as mentioned, the toolbar is displayed. All three of these objects are created by methods of the **Act** class. Each menu item or toolbar button is an object of the Action class. All the necessary actions are created by methods of the Act class. That is why this is probably the largest class in this program in terms of number of lines. But it is also probably the simplest class in this program, since all Actions are created in the same way, and the menu and toolbar are simply a listing of the necessary actions in the correct order. However, there are some small nuances that are easy to understand by looking at the text of the class.

The status bar is the **StatusBar** class. The status bar is actually a JPanel with three JTextFields. The class has three methods for displaying a string message in the corresponding JTextField. The rightmost field is a bit unusual: the message is displayed for 5 seconds and then erased. Of course, the status bar can be infinitely complicated and improved, but in this application, such a line is quite enough.

What Java program does not allow the user to install [L&F](https://en.wikipedia.org/wiki/Look_and_feel)? This program is no exception. In the View menu, the user can select any L&F available on his system. The Act class uses the **LaF** class to work with L&F.

The program opens files for display in the table. Swing provides a ready-made window for choosing a file - javax.swing.JFileChooser. The **Filer** class is just a wrapper around it, allowing you to slightly customize the appearance and behavior.

The **LastFiles** class is essential for Filer to work. LastFiles stores and reads several special strings using Proper â€” paths to the last opened files. It is very convenient to see them in the File menu and quickly specify the desired file, instead of using the open file dialog. Filer saves the path in LastFiles every time a file is successfully opened. If for some reason the file could not be opened, it removes this path from the list of saved files, if any. LastFiles provides the put() and remove() methods for these actions. In addition, there is a getList() method, with which Act forms a fragment of the File menu with a list of last opened files.

If the user has specified a file, then Filer will call the only public method convert() of the **Converor** class in the open() method. This method converts the original file with data in the form of key-value pairs into an HTML file with the same data presented in the form of a table. This HTML file will then be passed to JEditorPane, which will display it without any intervention from the programmer.

To implement the search in the displayed file, the **Finder** class was created. **FinderFrame** is a frame for entering a search string, which is a set of javax.swing components. The search algorithm is implemented in the Finder class. When creating FinderFrame, there was a need to place components, and for this purpose, the **GBL** class was created. GBL is a simplification of the GridBagLayout layout manager, adapted to the needs of the application.

And finally, let's get back to JEditorPane. To implement [D&D](https://en.wikipedia.org/wiki/drag_and_drop), the **DropTarget** class is created in the BankViewer.makeJEditorPane() method. Just a few lines of code allow the user to simply drag a file from Explorer into the application window and it will be opened.
